#' timeavestats
#'
#' Evaluates confidence intervals around time-averaging statistics
#' using bootstrapping while incorporating dating uncertainty.
#' Accepts object of the class 'postidst' generated by function
#' \code{\link{postdist}}
#'
#' @details The function timeavestats returns sample-level observed
#' and bootstrap statistics including naive bootstrap 95 percent
#' confidence intervals
#'
#' The following parameters are returned (for details and references
#' see \code{\link{postdist}}:
#'
#' observed sample stats: mean (mean age), median (median age),
#' TAV (total variance), TAVexact ("exact" total variance), AEV (age estimation
#' variance), AEVexact ("exact" age estimation variance), ETA (estimated time
#' averaging), ETAexact ("exact" estimated time averaging), OTA (uncorrected
#' estimate of time averaging - 2 times std.dev), iqr (interquartile range of ages),
#' g1 (parametric sample skeweness estimate), t3 (l-skewness)
#'
#' The corresponding bootstrap statistics with 95 percent naive bootstrap
#' confidence intervals are also included.
#'
#'
#' @param x A list of class 'postdist' returned by \code{\link{postdist}} function
#'
#' @param times A numerical value indicating number of replicate
#' bootstrap samples desired
#'
#' @return A dataframe with sample-level statistics
#'
#' @examples
#'
#' out1 <- postdist(age=florida$post$cal.BP, prob=florida$post$probability,
#' id=florida$post$UniqueID, idname='id', size=10000, outdata = TRUE)
#'
#' timeavestats(out1, times=100)
#'
#' @importFrom lmom samlmu
#' @importFrom stats var sd median
#'
#' @export
#'

timeavestats <- function(x, times=100) {
  if (!('postdist' %in% class(x))) stop('object of the class "postdist" is required')
  if (length(x)==2) stop('"outdata" is missing: re-run function "postdist" with outdata=TRUE')
  nspec <- ncol(x$outdata) # number of specimens
  iter <- nrow(x$outdata) # number of replicate ages in Monte Carlo distributions
  y <- as.vector(x$outdata) # vectorize posterior distributions
  out1 <- NULL
  etaout <- vector(mode='numeric', length=times)
  for (i in 1:times) {
    sel.sam <- sample(1:nspec, replace=T)     # select a bootstrap sample of specimens
    # the next line is not vectorized and slows down the script (which would be pretty fast otherwise)
    ETAboot <- 2 * sqrt(stats::var(as.vector(x$outdata[,sel.sam])) - mean(x$spec$ex.var[sel.sam]))
    sel.spec <- (sel.sam - 1)*iter + sample(1:iter, size=nspec, replace=T) # select ages for bootstrap sample from posterior distributions
    rsam <- y[sel.spec] # select a sample of ages for a bootstrap sample rsam
    out1 <- rbind(out1, rsam) # append
    etaout[i] <- ETAboot
  }
  # compute bootstrap stats for the analyzed sample:
  obs.stats <- data.frame(t(x$sample))
  samcts <- apply(out1, 2, mean)
  samctscorr <- samcts - (mean(samcts) - obs.stats$mean) # simple bootstrap correction
  samctscorrCL <- as.vector(stats::quantile(samctscorr, c(.025, .975)))
  samcts2 <- apply(out1, 2, stats::median)
  samcts2corr <- samcts2 - (stats::median(samcts2) - obs.stats$median) # simple bootstrap correction
  samcts2corrLL <- as.vector(stats::quantile(samcts2corr, .025))
  samcts2corrUL <- as.vector(stats::quantile(samcts2corr, .975))
  samsd <- apply(out1, 2, function(x) 2 * stats::sd(x))
  samsdcorr <- samsd - (mean(samsd) - obs.stats$OTA) # simple bootstrap correction
  samsdcorrLL <- as.vector(stats::quantile(samsdcorr, .025))
  samsdcorrUL <- as.vector(stats::quantile(samsdcorr, .975))
  etabcorr <- etaout - (mean(etaout) - obs.stats$ETA)
  etaCL <- as.vector(stats::quantile(etabcorr, c(.025, .975)))
  iqrb <- apply(out1, 2, stats::IQR)
  iqrcorr <- iqrb - (mean(iqrb) - obs.stats$iqr) # simple bootstrap correction
  g1F <- function(x) (sum((x-mean(x))^3)/length(x)) / stats::var(x)^(3/2)
  g1b <- apply(out1, 2, g1F)
  g1bcorr <- g1b - (mean(g1b) - obs.stats$g1) # simple bootstrap correction
  g1bCL <- as.vector(stats::quantile(g1bcorr, c(.025, .975)))
  iqrCL <- as.vector(stats::quantile(iqrcorr, c(.025, .975)))
  t3b <- apply(out1, 2, function(x) as.numeric(lmom::samlmu(x)[3]))
  t3bcorr <- t3b - (mean(t3b) - obs.stats$t3)
  t3bCL <- as.vector(stats::quantile(t3bcorr, c(.025, .975)))
  bstats <- data.frame(c(meanb=mean(samcts), meanbcorr=mean(samctscorr),
                         meanbL= samctscorrCL[1], meanbU= samctscorrCL[2],
                         medianb=stats::median(samcts2), medianbcorr=stats::median(samcts2corr),
                         medianbL=samcts2corrLL, medianbU=samcts2corrUL,
                         ETAb=mean(etaout), ETAbcorr=mean(etabcorr),
                         ETAbL=etaCL[1], ETAbU=etaCL[2],
                         OTAb=mean(samsd), OTAbcorr=mean(samsdcorr),
                         OTAbL=samsdcorrLL, OTAbU=samsdcorrUL,
                         iqrb=mean(iqrb), iqrbcorr=mean(iqrcorr),
                         iqrbL=iqrCL[1], iqrbU=iqrCL[2], g1b=mean(g1b),
                         g1bcorr=mean(g1bcorr), g1bL=g1bCL[1], g1bU=g1bCL[2],
                         t3b=mean(t3b), t3bcorr=mean(t3bcorr),
                         t3bL=t3bCL[1], t3bU=t3bCL[2]))
  fin <- data.frame(x$sample)
  colnames(fin) <- colnames(bstats) <- x$samid
  return(rbind(fin, bstats))
}
